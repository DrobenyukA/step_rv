<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"/>
	<meta name="description" content=""/>
	<meta name="keywords" content=""/>
	<meta name=viewport content="width=device-width, initial-scale=1"/>	
	<title>Chain of Responsibility - pattern</title>
	<link rel="stylesheet" href="../css/reset.css"/>
	<link rel="stylesheet" href="../css/peter_page_style.css"/>
</head>
	<body>
	<main class="main-page"> 
			<header> 
				<h1><span>Паттерн</span> <b>Chain of Responsibility</b></h1>
			</header>
				<section>
					<div class="buttons">
						<div class="button">
							<a href="../index.html">
							<h4>home</h4>
							</a>
						</div>
					</div>
					<div class="arrow">
						<a href="#top" title="go on top"></a>
					</div>
	<h2>Название и классификация паттерна</h2>
	<p><b>Ц</b>епочка обязанностей - паттерн поведения объектов.</p>
	<h2>Назначение</h2>
	<p>
		<b>П</b>озволяет избежать привязки отправителя запроса к его получателю, давая шанс обработать запрос нескольким объектам. Связывает объекты-получатели в цепочку и передает запрос вдоль этой цепочки, пока его не обработают.
	</p>
	<h2>Мотивация</h2>
	<p>
		<b>Р</b>ассмотрим контекстно-зависимую оперативную справку в графическом интерфейсе пользователя, который может получить дополнительную информацию по любой части интерфейса, просто щелкнув на ней мышью. Содержание справки зависит от того, какая часть интерфейса и в каком контексте выбрана. Например, справка по кнопке в диалоговом окне может отличаться от справки по аналогичной кнопке в главном окне приложения. Если для некоторой части интерфейса справки нет, то система должна показать информацию о ближайшем контексте, в котором она находится, например о диалоговом окне в целом.
	</p>
	<p>
		<b>П</b>оэтому естественно было бы организовать справочную информацию от более конкретных разделов к более общим. Кроме того, ясно, что запрос на получение справки обрабатывается одним из нескольких объектов пользовательского интерфейса, каким именно - зависит от контекста и имеющейся в наличии информации.
	</p>
	<p>
		<b>П</b>роблема в том, что объект, инициирующий запрос (например, кнопка), не располагает информацией о том, какой объект в конечном итоге предоставит справку. Нам необходим какой-то способ отделить кнопку-инициатор запроса от объектов, владеющих справочной информацией. Как этого добиться, показывает паттерн цепочка обязанностей.
	</p>
	<p>
		<b>И</b>дея заключается в том, чтобы разорвать связь между отправителями и получателями, дав возможность обработать запрос нескольким объектам. Запрос перемещается по цепочке объектов, пока один из них не обработает его.
	</p>
	<p>
		<b>П</b>ервый объект в цепочке получает запрос и либо обрабатывает его сам, либо направляет следующему кандидату в цепочке, который ведет себя точно так же. У объекта, отправившего запрос, отсутствует информация об обработчике. Мы говорим, что у запроса есть анонимный получатель (implicit receiver).
	</p>
			<img src="../img/pages/1/pg_1_1.png" alt="scheme"/>
	<p>
		<b>П</b>редположим, что пользователь запрашивает справку по кнопке Print (печать). Она находится в диалоговом окне Pr intDialog, содержащем информацию об объекте приложения, которому принадлежит (см. предыдущую диаграмму объектов). На представленной диаграмме взаимодействий показано, как запрос на получение справки перемещается по цепочке.
	</p>
			<img src="../img/pages/1/pg_1_2.png" alt="scheme"/>
	<p>
		<b>В</b> данном случае ни кнопка aPrintButton, ни окно aPrintDialog не обрабатывают запрос, он достигает объекта anApplication, который может его обработать или игнорировать. У клиента, инициировавшего запрос, нет прямой ссылки на объект, который его в конце концов выполнит.
	</p>
	<p>
		<b>Ч</b>тобы отправить запрос по цепочке и гарантировать анонимность получателя, все объекты в цепочке имеют единый интерфейс для обработки запросов и для доступа к своему преемнику (следующему объекту в цепочке). Например, в системе оперативной справки можно было бы определить класс HelpHandler (предок классов всех объектов-кандидатов или подмешиваемый класс (mixin class)) с операцией HandleHelp. Тогда классы, которые будут обрабатывать запрос, смогут его передать своему родителю.
	</p>
	<p>
		<b>Д</b>ля обработки запросов на получение справки классы Button, Dialog и Application пользуются операциями HelpHandler. По умолчанию операция HandleHelp просто перенаправляет запрос своему преемнику. В подклассах эта операция замещается, так что при благоприятных обстоятельствах может выдаваться справочная информация. В противном случае запрос отправляется дальше посредством реализации по умолчанию.
	</p>
			<img src="../img/pages/1/pg_1_3.png" alt="scheme"/>
	<h2>Применимость</h2>
	<p>
		<b>И</b>
		спользуйте цепочку обязанностей, когда:
	</p>
	<ul>
		<li>
			есть более одного объекта, способного обработать запрос, причем настоящий обработчик заранее неизвестен и должен быть найден автоматически;
		</li>
		<li>
			вы хотите отправить запрос одному из нескольких объектов, не указывая явно, какому именно;
		</li>
		<li>
			набор объектов, способных обработать запрос, должен задаваться динамически.
		</li>
	</ul>
	<h2>Структура</h2>
			<img src="../img/pages/1/pg_1_4.png" alt="structure"/>
	<h3>Типичная структура объектов.</h3>
			<img src="../img/pages/1/pg_1_5.png" alt="structure"/>
	<h2>Участники</h2>
	<p>
		<b>Handler</b> (HelpHandler) &mdash; <b>обработчик:</b>
	</p>
			<ul class="line">
				<li>определяет интерфейс для обработки запросов;</li>
				<li>(необязательно) реализует связь с преемником;</li>
			</ul>
	<p>
		<b>ConcreteHandler</b> (PrintButton, PrintDialog) &mdash; конкретный обработчик:
	</p>
	<ul class="line">
		<li>обрабатывает запрос, за который отвечает;</li>
		<li>имеет доступ к своему преемнику;</li>
		<li>если ConcreteHandler способен обработать запрос, то так и делает, если не может, то направляет его - его своему преемнику;</li>
	</ul>
	<p>
		<b>Client</b> &mdash; клиент:
	</p>
	<ul class="line">
		<li>отправляет запрос некоторому объекту ConcreteHandler в цепочке.</li>
	</ul>
	<h2>Отношения</h2>
	<p><b>К</b>огда клиент инициирует запрос, он продвигается по цепочке, пока некоторый объект ConcreteHandler не возьмет на себя ответственность за его обработку.</p>
	<h2>Результаты</h2>
	<p><b>П</b>аттерн цепочка обязанностей имеет следующие достоинства и недостатки:</p>
	<ul>
		<li>
			<em>ослабление связанности.</em> Этот паттерн освобождает объект от необходимости «знать», кто конкретно обработает его запрос. Отправителю и получателю ничего неизвестно друг о друге, а включенному в цепочку объекту - о структуре цепочки.<br/>
			Таким образом, цепочка обязанностей помогает упростить взаимосвязи между объектами. Вместо того чтобы хранить ссылки на все объекты, которые могут стать получателями запроса, объект должен располагать информацией лишь о своем ближайшем преемнике;
		</li>
		<li>
			<em>дополнительная гибкость при распределении обязанностей между объектами.</em> Цепочка обязанностей позволяет повысить гибкость распределения обязанностей между объектами. Добавить или изменить обязанности по обработке запроса можно, включив в цепочку новых участников или изменив ее каким-то другим образом. Этот подход можно сочетать со статическим порождением подклассов для создания специализированных обработчиков;
		</li>
		<li>
			<em>получение не гарантировано.</em> Поскольку у запроса нет явного получателя, то нет и гарантий, что он вообще будет обработан: он может достичь конца цепочки и пропасть. Необработанным запрос может оказаться и в случае неправильной конфигурации цепочки.
		</li>
	</ul>
	<h2>Реализация</h2>
	<p><b>П</b>ри рассмотрении цепочки обязанностей следует обратить внимание на следующие моменты:</p>
	<ul>
		<li>
			<em>реализация цепочки преемников.</em> Есть два способа реализовать такую цепочку: 
			<ul class="line">
				<li>
					определить новые связи (обычно это делается в классе Handler, но можно и в ConcreteHandler);
				</li>
				<li>
					использовать существующие связи.
				</li>
			</ul>
			До сих пор в наших примерах определялись новые связи, однако можно воспользоваться уже имеющимися ссылками на объекты для формированияцепочки преемников. Например, ссылка на родителя в иерархии «часть-целое» может заодно определять и преемника «части». В структуре виджетов такие связи тоже могут существовать. В разделе, посвященном паттерну компоновщик, ссылки на родителей обсуждаются более подробно. Существующие связи можно использовать, когда они уже поддерживают нужную цепочку. Тогда мы избежим явного определения новых связей и сэкономим память. Но если структура не отражает устройства цепочки обязанностей, то уйти от определения избыточных связей не удастся;
		</li>
		<li>
			<em>соединение преемников.</em> Если готовых ссылок, пригодных для определения цепочки, нет, то их придется ввести. В таком случае класс Handler не только определяет интерфейс запросов, но еще и хранит ссылку на преемника.Следовательно у обработчика появляется возможность определить реализацию операции HandleRequest по умолчанию - перенаправление запроса преемнику (если таковой существует). Если подкласс ConcreteHandler не заинтересован в запросе, то ему и не надо замещать эту операцию, поскольку по умолчанию запрос как раз и отправляется дальше. Вот пример базового класса HelpHandler, в котором хранится указатель на преемника:
			<pre>
			<span class="cl_bl">class</span> <span class="cl_nm_gr">HelpHandler</span> {
			public:
				HelpHandler(HelpHandler<span class="cl_symb">*</span> s) <span class="cl_symb">:</span> _successor(s) { }
				<span class="cl_bl">virtual void</span> HandleHelp();
			private:
				HelpHandler<span class="cl_symb">*</span> _successor;
			};
				<span class="cl_bl">void</span> HelpHandler<span class="cl_symb">::</span>HandleHelp () {
				<span class="cl_bl">if</span> (_successor) {
					_successor<span class="cl_symb">-></span>HandleHelp();
				}
			}</pre>
		</li>
		<li>
			<em>представление запросов.</em> Представлять запросы можно по-разному. В простейшей форме, например в случае класса HandleHelp, запрос жестко кодируется как вызов некоторой операции. Это удобно и безопасно, но переадресовывать тогда можно только фиксированный набор запросов, определенных в классе Handler.<br/>
			Альтернатива &ndash; использовать одну функцию-обработчик, которой передается код запроса (скажем, целое число или строка). Так можно поддержать заранее неизвестное число запросов. Единственное требование состоит в том, что отправитель и получатель должны договориться о способе кодирования запроса.<br/>
			Это более гибкий подход, но при реализации нужно использовать условные операторы для раздачи запросов по их коду. Кроме того, не существует безопасного с точки зрения типов способа передачи параметров, поэтому упаковывать и распаковывать их приходится вручную. Очевидно, что это не так безопасно, как прямой вызов операции. <br/>
			Чтобы решить проблему передачи параметров, допустимо использовать отдельные <em>объекты-запросы</em>, в которых инкапсулированы параметры запроса. Класс Request может представлять некоторые запросы явно, а их новые типы описываются в подклассах. Подкласс может определить другие параметры. Обработчик должен иметь информацию о типе запроса (какой именно подкласс Request используется), чтобы разобрать эти параметры.<br/>
			Для идентификации запроса в классе Request можно определить функцию доступа, которая возвращает идентификатор класса. Вместо этого получатель мог бы воспользоваться информацией о типе, доступной во время выполнения, если язык программирования поддерживает такую возможность. Приведем пример функции диспетчеризации, в которой используются объекты для идентификации запросов. Операция GetKind, указанная в базовом классе Request, определяет вид запроса:
			<pre>
			<span class="cl_bl">void</span> Handler<span class="cl_symb">::</span>HandleRequest (Request<span class="cl_symb">*</span> theRequest) {
				<span class="cl_bl">switch</span> (theRequest<span class="cl_symb">-></span>GetKind()) {
				<span class="cl_bl">case</span> Help:
					<span class="cl_com">// привести аргумент к походящему типу</span>
					HandleHelp((HelpRequest<span class="cl_symb">*</span>) theRequest);
					<span class="cl_bl">break</span>;
				<span class="cl_bl">case</span> Print:
					HandlePrint((PrintRequest<span class="cl_symb">*</span>) theRequest);
					<span class="cl_com">// ...</span>
					<span class="cl_bl">break</span>;
				default:
					<span class="cl_com">// ...</span>
					<span class="cl_bl">break</span>;
				}
			}</pre>
			Подклассы могут расширить схему диспетчеризации, переопределив операцию HandleRequest. Подкласс обрабатывает лишь те запросы, в которых заинтересован, а остальные отправляет родительскому классу. В этом случае подкласс именно расширяет, а не замещает операцию HandleRequest. Подкласс ExtendedHandler расширяет операцию HandleRequest, определенную в классе Handler, следующим образом:
			<pre>
			<span class="cl_bl">class</span> <span class="cl_nm_gr">ExtendedHandler</span> <span class="cl_symb">:</span> <span class="cl_bl">public</span> Handler {
				public:
					<span class="cl_bl">virtual void</span> HandleRequest(Request<span class="cl_symb">*</span> theRequest);
					<span class="cl_com">// . . .</span>
			};
			<span class="cl_bl">void</span> ExtendedHandler<span class="cl_symb">::</span>HandleRequest (Request<span class="cl_symb">*</span> theRequest) {
				<span class="cl_bl">switch</span> (theRequest<span class="cl_symb">-></span>GetKind()) {
				<span class="cl_bl">case</span> Preview:
					<span class="cl_com">// обработать запрос Preview</span>
					<span class="cl_bl">break</span>;
				<span class="cl_bl">default</span>:
					<span class="cl_com">// дать классу Handler возможность обработать</span>
					<span class="cl_com">// остальные запросы</span>
					Handler<span class="cl_symb">::</span>HandleRequest(theRequest);
				}
			}</pre>
		</li>
		<li>
			<em>автоматическое перенаправление запросов в языке Smalltalk.</em> С этой целью можно использовать механизм doesNotUnderstand. Сообщения, не имеющие соответствующих методов, перехватываются реализацией doesNotUnderstand, которая может быть замещена для перенаправления сообщения объекту-преемнику. Поэтому осуществлять перенаправление вручную необязательно. Класс обрабатывает только запросы, в которых заинтересован, и ожидает, что механизм doesNotUnderstand выполнит все остальное.
		</li>
	</ul>
	<h2>Пример кода</h2>
	<p><b>В</b> следующем примере иллюстрируется, как с помощью цепочки обязанностей можно обработать запросы к описанной выше системе оперативной справки. Запрос на получение справки - это явная операция. Мы воспользуемся уже имеющимися в иерархии виджетов ссылками для перемещения запросов по цепочке от одного виджета к другому и определим в классе Handler отдельную ссылку, чтобы можно было передать запрос включенным в цепочку объектам, не являющимся виджетами.</p>
	<p>
		<b>К</b>ласс HelpHandler определяет интерфейс для обработки запросов на получение справки. В нем хранится раздел справки (по умолчанию пустой) и ссылка на преемника в цепочке обработчиков. Основной операцией является HandleHelp, которая замещается в подклассах. HasHelp - это вспомогательная операция, проверяющая, ассоциирован ли с объектом какой-нибудь раздел:
	</p>
		<pre>
			<span class="cl_bl">typedef</span> int Topic;
			<span class="cl_bl">const</span> Topic NO_HELP_TOPIC <span class="cl_symb">= -</span><span class="cl_nmb">1</span>;

			<span class="cl_bl">class</span> <span class="cl_nm_gr">HelpHandler</span> {
			public:
				HelpHandler (HelpHandler<span class="cl_symb">* =</span> <span class="cl_nmb">0</span>, Topic <span class="cl_symb">=</span> NO_HELP_TOPIC) ;
				<span class="cl_bl">virtual bool</span> HasHelpO;
				<span class="cl_bl">virtual void</span> <span class="cl_nm_gr">SetHandler</span> (HelpHandler<span class="cl_symb">*</span>, Topic);
				<span class="cl_bl">virtual void</span> <span class="cl_nm_gr">HandleHelp</span> ( ) ;
			private:
				HelpHandler<span class="cl_symb">*</span> _successor;
				Topic _topic;
			};

			HelpHandler<span class="cl_symb">::</span>HelpHandler (
				HelpHandler<span class="cl_symb">*</span> h, Topic t
			) <span class="cl_symb">:</span> _successor(h), _topic(t) { }
			<span class="cl_bl">bool</span> HelpHandler<span class="cl_symb">::</span>HasHelp () {
				<span class="cl_bl">return</span> _topic <span class="cl_symb">!=</span> NO_HELP_TOPIC;
			}

			<span class="cl_bl">void</span> HelpHandler<span class="cl_symb">::</span>HandleHelp () {
				<span class="cl_bl">if</span> (<span class="cl_symb">„</span>successor <span class="cl_symb">!=</span> <span class="cl_nmb">0</span>) {
				_successor<span class="cl_symb">-></span>HandleHelp();
				}
			}</pre>
	
	<p>
		<b>В</b>се виджеты - подклассы абстрактного класса Widget, который, в свою очередь, является подклассом HelpHandler, так как со всеми элементами пользовательского интерфейса может быть ассоциирована справочная информация. (Можно было, конечно, построить реализацию и на основе подмешиваемого класса.)
	</p>
		<pre>
			<span class="cl_bl">class</span> <span class="cl_nm_gr">Widget</span> <span class="cl_symb">:</span> <span class="cl_bl">public</span> HelpHandler {
			protected:
				Widget(Widget<span class="cl_symb">*</span> parent, Topic t <span class="cl_symb">=</span> NO_HELP_TOPIC);
			private:
				Widget<span class="cl_symb">*</span> _parent;
			};
			Widget<span class="cl_symb">::</span>Widget (Widget<span class="cl_symb">*</span> w, Topic t) <span class="cl_symb">:</span> HelpHandler(w, t) {
				_parent <span class="cl_symb">=</span> w;
			}</pre>
	<p>
		<b>В</b> нашем примере первым обработчиком в цепочке является кнопка. Класс Button - это подкласс Widget. Конструктор класса Button принимает два параметра - ссылку на виджет, в котором он находится, и раздел справки:
	</p>
		<pre>
			<span class="cl_bl">class</span> <span class="cl_nm_gr">Button</span> <span class="cl_symb">:</span> <span class="cl_bl">public</span> Widget {
			public:
				Button (Widget<span class="cl_symb">*</span> d, Topic t <span class="cl_symb">=</span> NO_HELP_TOPIC) ;
				<span class="cl_bl">virtual void</span> <span class="cl_nm_gr">HandleHelp</span> ();
				<span class="cl_com">// операции класса Widget, которые Button замещает...</span>
			};</pre>
	<p>
		<b>Р</b>еализация HandleHelp в классе Button сначала проверяет, есть ли для кнопки справочная информация. Если разработчик не определил ее, то запрос отправляется преемнику с помощью операции HandleHelp класса HelpHandler. Если же информация есть, то кнопка ее отображает и поиск заканчивается:
	</p>
		<pre>
			Button<span class="cl_symb">::</span>Button (Widget<span class="cl_symb">*</span> h, Topic t) <span class="cl_symb">:</span> Widget(h, t) { }
			
			<span class="cl_bl">void</span> Button<span class="cl_symb">::</span>HandleHelp () {
				<span class="cl_bl">if</span> (HasHelp()) {
					<span class="cl_com">// предложить справку по кнопке</span>
				} <span class="cl_bl">else</span> {
					HelpHandler<span class="cl_symb">::</span>HandleHelp();
				}
			}</pre>
	
	<p>
		<b>К</b>ласс Dialog реализует аналогичную схему, только его преемником является не виджет, а <em>произвольный</em> обработчик запроса на справку. В нашем приложении таким преемником выступает экземпляр класса Application:
	</p>
		<pre>
			<span class="cl_bl">class</span> <span class="cl_nm_gr">Dialog</span> <span class="cl_symb">:</span> <span class="cl_bl">public</span> Widget {
			public:
				Dialog(HelpHandler<span class="cl_symb">*</span> h, Topic t <span class="cl_symb">=</span> NO_HELP_TOPIC);
				<span class="cl_bl">virtual void</span> <span class="cl_nm_gr">HandleHelp</span>();
				<span class="cl_com">// операции класса Widget, которые Dialog замещает...</span>
				<span class="cl_com">// . . .</span>
			};
			Dialog<span class="cl_symb">::</span>Dialog (HelpHandler<span class="cl_symb">*</span> h, Topic t) <span class="cl_symb">:</span> Widget(<span class="cl_nmb">0</span>) {
				SetHandler(h, t);
			}
			<span class="cl_bl">void</span> Dialog::HandleHelp () {
				<span class="cl_bl">if</span> (HasHelpO) {
					<span class="cl_com">// предложить справку по диалоговому окну</span>
				} <span class="cl_bl">else</span> {
					HelpHandler<span class="cl_symb">::</span>HandleHelp();
				}
			}
		</pre>
	<p>
		<b>В</b> конце цепочки находится экземпляр класса Appl icat ion. Приложение - это не виджет, поэтому Application - прямой потомок класса HelpHandler. Если запрос на получение справки дойдет до этого уровня, то класс Appl icat ion может выдать информацию о приложении в целом или предложить список разделов:
	</p>
		<pre>
			<span class="cl_bl">class</span> <span class="cl_nm_gr">Application</span> <span class="cl_symb">:</span> <span class="cl_bl">public</span> HelpHandler {
			public:
				Application(Topic t) <span class="cl_symb">:</span> HelpHandler(<span class="cl_nmb">0</span>, t) { }
				<span class="cl_bl">virtual</span> void HandleHelp();
				<span class="cl_com">// операции, относящиеся к самому приложению...</span>
			};
			<span class="cl_bl">void</span> Application<span class="cl_symb">::</span>HandleHelp () {
				<span class="cl_com">// показать список разделов справки</span>
			}
		</pre>
	<p>
		<b>С</b>ледующий код создает и связывает эти объекты. В данном случае рассматривается диалоговое окно <b>Print</b>, поэтому с объектами связаны разделы справки, касающиеся печати:
	</p>
		<pre>
			<span class="cl_bl">const</span> Topic PRINT_TOPIC <span class="cl_symb">=</span> <span class="cl_nmb">1</span>;
			<span class="cl_bl">const</span> Topic PAPER_ORIENTATION_TOPIC <span class="cl_symb">=</span> <span class="cl_nmb">2</span>;
			<span class="cl_bl">const</span> Topic APPLICATIONJTOPIC <span class="cl_symb">=</span> <span class="cl_nmb">3</span>;

			Application<span class="cl_symb">*</span> application <span class="cl_symb">=</span> <span class="cl_bl">new</span> Application (APPLICATIONJTOPIC) ;
			Dialog<span class="cl_symb">*</span> dialog <span class="cl_symb">=</span> <span class="cl_bl">new</span> Dialog (application, PRINTJTOPIC) ;
			Button<span class="cl_symb">*</span> button <span class="cl_symb">=</span> <span class="cl_bl">new</span> Button (dialog, PAPER_ORIENTATION_TOPIC) ;</pre>
	<p>
		<b>М</b>ы можем инициировать запрос на получение справки, вызвав операцию HandleHelp для любого объекта в цепочке. Чтобы начать поиск с объекта кнопки, достаточно выполнить его операцию HandleHelp:
	</p>
		<pre>
			button<span class="cl_symb">-></span>HandleHelp();</pre>
	<p>
		<b>В</b> этом примере кнопка обрабатывает запрос сразу же. Заметим, что класс HelpHandler можно было бы сделать преемником Dialog. Более того, его преемника можно изменять динамически. Вот почему, где бы диалоговое окно ни встретилось, вы всегда получите справочную информацию с учетом контекста.
	</p>
	<h2>Известные применения</h2>
	<p>
		<b>П</b>аттерн цепочка обязанностей используется в нескольких библиотеках классов для обработки событий, инициированных пользователем. Класс Handler в них называется по-разному, но идея всегда одна и та же: когда пользователь щелкает кнопкой мыши или нажимает клавишу, генерируется некоторое событие, которое распространяется по цепочке. В МасАрр [Арр89] и ЕТ++ [WGM88] класс называется Event Handler, в библиотеке TCL фирмы Symantec [Sym93b] Bureaucrat, а в библиотеке из системы NeXT [Add94] Responder.
	</p>
	<p>
		<b>В</b> каркасе графических редакторов Unidraw определены объекты Command, которые инкапсулируют запросы к объектам Component и Component View [VL90]. Объекты Command - это запросы, которые компонент или вид компонента могут интерпретировать как команду на выполнение определенной операции. Это соответствует подходу «запрос как объект», описанному в разделе «Реализация». Компоненты и виды компонентов могут быть организованы иерархически. Как компонент, так и его вид могут перепоручать интерпретацию команды своему родителю, тот - своему родителю и так далее, то есть речь идет о типичной цепочке обязанностей.
	</p>
	<p>
		<b>В</b> ЕТ++ паттерн цепочка обязанностей применяется для обработки запросов на обновление графического изображения. Графический объект вызывает операцию InvalidateRect всякий раз, когда возникает необходимость обновить часть занимаемой им области. Но выполнить эту операцию самостоятельно графический объект не может, так как не имеет достаточной информации о своем контексте, например из-за того, что окружен такими объектами, как Scroller (полоса прокрутки) или Zoomer (лупа), которые преобразуют его систему координат. Это означает, что объект может быть частично невидим, так как он оказался за границей области прокрутки или изменился его масштаб. Поэтому реализация InvalidateRect по умолчанию переадресует запрос контейнеру, где находится соответствующий объект. Последний объект в цепочке обязанностей — экземпляр класса Window. Гарантируется, что к тому моменту, как Window получит запрос, недействительный прямоугольник будет трансформирован правильно. Window обрабатывает InvalidateRect, послав запрос интерфейсу оконной системы и требуя тем самым выполнить обновление.
	</p>
	<h2>Родственные паттерны</h2>
	<p>
		<b>П</b>аттерн цепочка обязанностей часто применяется вместе с паттерном компоновщик. В этом случае родитель компонента может выступать в роли его преемника.
	</p>
		</section>
			<footer>
						<div class="copy">
							<h3> Made by El_paso - Rivne 2016</h3>
						</div> 
			</footer>
		</main>
	</body>
</html>