<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"/>
	<meta name="description" content=""/>
	<meta name="keywords" content=""/>
	<meta name=viewport content="width=device-width, initial-scale=1">	
	<title>Template Method - pattern</title>
	<link rel="stylesheet" href="../css/reset.css"/>
	<link rel="stylesheet" href="../css/anatoliy_page_style.css"/>
</head>
<body>
    <header>
        <div class="text">
            <h4>design Patterns</h4>
        </div>
        <h2>паттерн template method</h2>
        <div class="button">
            <a href="../index.html">
                <h4>home</h4>
            </a>
        </div>
    </header>
    <main>
        <div class="arrow">
        <a href="#top" title="go on top"></a>
        </div>
    	<h2>Название и классификация паттерна</h2>
    	<p>
            <b>Ш</b>аблонный метод — паттерн поведения классов.
        </p>
    	<h2>Назначение</h2>
    	<p>
    	    <b>Ш</b>аблонный метод определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма, не изменяя его структуру в целом.
    	</p>
    	<h2>Мотивация</h2>
    	<p>
    	    <b>Р</b>ассмотрим каркас приложения, в котором имеются классы Application и Document. Класс Application отвечает за открытие существующих документов, хранящихся во внешнем формате, например в виде файла. Объект класса Document представляет информацию документа после его прочтения из файла.
    	</p>
    	<p>
    	    <b>П</b>риложения, построенные на базе этого каркаса, могут порождать подклассыот классов Application и Document, отвечающие конкретным потребностям.Например, графический редактор определит подклассы DrawApplicationи DrawDocument, а электронная таблица — подклассы Spreadsheet Application и SpreadsheetDocument.
    	</p>
    	<img src="../img/pages/10/pg_10_1.png" height="253" width="544" alt="scheme">
    	<p>
    	   <b>В</b> абстрактном классе Application определен алгоритм открытия и считывания документа в операции OpenDocument:
        </p>
    	<pre>
    	<span class="cl_bl">void</span> Application<span class="cl_symb">::</span>OpenDocument (const char<span class="cl_symb">*</span> name) {
            <span class="cl_bl">if</span> (!CanOpenDocument(name)) {
                <span class="cl_com">// работа с этим документом невозможна</span>
                <span class="cl_bl">return</span>;
    				}
    		    Document<span class="cl_symb">*</span> doc <span class="cl_symb">=</span> DoCreateDocument();

    		    <span class="cl_bl">if</span> (doc) {

    		        _docs<span class="cl_symb">-></span>AddDocument(doc);
                AboutToOpenDocument(doc);
                doc<span class="cl_symb">-></span>0pen();
                doc<span class="cl_symb">-></span>DoRead();
            }
        }
        </pre>
        <p>
            <b>О</b>перация OpenDocument определяет все шаги открытия документа. Она проверяет, можно ли открыть документ, создает объект класса Document, добавляет его к набору документов и считывает документ из файла.
        </p>
        <p>
            <b>О</b>перацию вида OpenDocument мы будем называть шаблонным методом, описывающим алгоритм в терминах абстрактных операций, которые замещены в подклассах для получения нужного поведения. Подклассы класса Appl icat ion выполняют проверку возможности открытия (CanOpenDocument) и создания документа(DoCreateDocument). Подклассы класса Document считывают документ (DoRead). Шаблонный метод определяет также операцию, которая позволяет подклассам Application получить информацию о том, что документ вот-вот будет открыт (AboutToOpenDocument). Определяя некоторые шаги алгоритма с помощью абстрактных операций, шаблонный метод фиксирует их последовательность, но позволяет реализовать их в подклассах классов Application и Document.
        </p>
        <h2>Применимость</h2>
        <p>
            <b>П</b>аттерн шаблонный метод следует использовать:
        </p>
        <ul>
            <li>
                чтобы однократно использовать инвариантные части алгоритма, оставляя реализацию изменяющегося поведения на усмотрение подклассов;
            </li>
            <li>
                когда нужно вычленить и локализовать в одном классе поведение, общее для всех подклассов, дабы избежать дублирования кода. Это хороший пример техники «вынесения за скобки с целью обобщения», описанной в работе Уильяма Опдайка (William Opdyke) и Ральфа Джонсона (Ralph Johnson)[OJ93]. Сначала идентифицируются различия в существующем коде, а затем они выносятся в отдельные операции. В конечном итоге различающиеся фрагменты кода заменяются шаблонным методом, из которого вызываются новые операции;
            </li>
            <li>
                для управления расширениями подклассов. Можно определить шаблонный метод так, что он будет вызывать операции-зацепки (hooks) - см. раздел «Результаты» - в определенных точках, разрешив тем самым расширение только в этих точках.
            </li>
         </ul>
         <h2>Структура</h2>
    	<img src="../img/pages/10/pg_10_2.png" height="209" width="396" alt="structure">
    	<h2>Участники</h2>
    	<p>
    		<b>AbstractClass</b> (Application) &mdash; <b>абстрактный класс:</b>
    	</p>
    	<ul>
    	    <li>
    	    определяет абстрактные примитивные операции, замещаемые в конкретных подклассах для реализации шагов алгоритма;
    	    </li>
    	    <li>
    	    реализует шаблонный метод, определяющий скелет алгоритма. Шаблоный метод вызывает примитивные операции, а также операции, определенные в классе AbstractClass или в других объектах;
    	    </li>
    	</ul>
    	<p>
    		<b>ConcreteClass</b> (MyApplication) &mdash; <b>конкретный класс:</b>
    	</p>
    	<ul>
    		<li>реализует примитивные операции, выполняющие шаги алгоритма способом, который зависит от подкласса.</li>
    	</ul>
    	<h2>Отношения</h2>
    	<p>
    	    <b>C</b>oncreteClass предполагает, что инвариантные шаги алгоритма будут выполнены в AbstractClass.
    	</p>
    	<h2>Результаты</h2>
    	<p>
    	    <b>Ш</b>аблонные методы - один из фундаментальных приемов повторного использования кода. Они особенно важны в библиотеках классов, поскольку предоставляют возможность вынести общее поведение в библиотечные классы.
    	</p>
        <p>
            <b>Ш</b>аблонные методы приводят к инвертированной структуре кода, которую иногда называют принципом Голливуда, подразумевая часто употребляемую в этой киноимперии фразу «Не звоните нам, мы сами позвоним» [Swe85]. В данном случае это означает, что родительский класс вызывает операции подкласса, а не наоборот.
        </p>
        <p>
            <b>Ш</b>аблонные методы вызывают операции следующих видов:
        </p>
        <ul>
            <li>
            конкретные операции (либо из класса ConcreteClass, либо из классов клиента);
            </li>
            <li>
            конкретные операции из класса AbstractClass (то есть операции, полезные всем подклассам);
            </li>
            <li>
            примитивные операции (то есть абстрактные операции);
            </li>
            <li>
            фабричные методы (см. паттерн фабричный метод);
            </li>
            <li>
            операции-зацепки (hook operations), реализующие поведение по умолчанию, которое может быть расширено в подклассах. Часто такая операция по умолчанию не делает ничего.
            </li>
        </ul>
        <p>
            <b>В</b>ажно, чтобы в шаблонном методе четко различались операции-зацепки (которые <em>можно</em> замещать) и абстрактные операции (которые <em>нужно</em> замещать). Чтобы повторно использовать абстрактный класс с максимальной эффективностью, авторы подклассов должны понимать, какие операции предназначены для замещения.
        </p>
        <p>
            <b>П</b>одкласс может расширить поведение некоторой операции, заместив ее и явно вызвав эту операцию из родительского класса:
        </p>
        <pre>
        <span class="cl_bl">void</span> DerivedClass<span class="cl_symb">::</span>Operation () {
            ParentClass<span class="cl_symb">::</span>Operation();
            <span class="cl_com">// Расширенное поведение класса Periveddass</span>
        }
        </pre>
        <p>
            <b>К</b> сожалению, очень легко забыть о необходимости вызывать унаследованную операцию. У нас есть возможность трансформировать такую операцию в шаблонный метод с целью предоставить родителю контроль над тем, как подклассы расширяют его. Идея в том, чтобы вызывать операцию-зацепку из шаблонного метода в родительском классе. Тогда подклассы смогут переопределить именно эту операцию:
        </p>
        <pre>
        <span class="cl_bl">void</span> ParentClass<span class="cl_symb">::</span>Operation () {
            <span class="cl_com">// Поведение родительского класса ParentClass
            HookOperation();</span>
        }
        </pre>
        <p>
            <b>В</b> родительском классе ParentClass операция HookOperation не делает ничего:
        </p>
        <pre>
        <span class="cl_bl">void</span> ParentClass<span class="cl_symb">::</span>Operation () {
        }
        </pre>
        <p>
            <b>Н</b>о она замещена в подклассах, которые расширяют поведение:
        </p>
        <pre>
        <span class="cl_bl">void</span> DerivedClass<span class="cl_symb">::</span>HookOperation () {
            <span class="cl_com">//расширение в производном классе</span>
        }
        </pre>
        <h2>Реализация</h2>
    	<p>
    	    <b>С</b>тоит рассказать о трех аспектах, касающихся реализации:
    	</p>
    	<ul>
    	    <li>
    	    <em>использование контроля доступа</em> в C++. В этом языке примитивные операции, которые вызывает шаблонный метод, можно объявить защищенными членами. Тогда гарантируется, что вызывать их сможет только сам шаблонный метод. Примитивные операции, которые <em>обязательно</em> нужно замещать, объявляются как чисто виртуальные функции. Сам шаблонный метод замещать не надо, так что его можно сделать невиртуальной функцией-членом;
    	    </li>
    	    <li>
    	    <em>сокращение числа примитивных операций</em>. Важной целью при проектировании шаблонных методов является всемерное сокращение числа примитивных операций, которые должны быть замещены в подклассах. Чем больше операций нужно замещать, тем утомительнее становится программирование клиента;
    	    </li>
    	    <li>
    	    <em>соглашение об именах</em>. Выделить операции, которые необходимо заместить, можно путем добавления к их именам некоторого префикса. Например, в каркасе МасАрр для приложений на платформе Macintosh [App89] имена шаблонных методов начинаются с префикса Do: DoCreateDocument, DoRead и т.д.
    	    </li>
    	</ul>
    	<h2>Пример кода</h2>
    	<p>
    	    <b>С</b>ледующий написанный на C++ пример показывает, как родительский класс может навязать своим подклассам некоторый инвариант. Пример взят из библиотеки NeXT AppKit [Add94]. Рассмотрим класс View, поддерживающий рисование на экране, - своего рода инвариант, заключающийся в том, что подклассы могут изменять вид только тогда, когда он находится в фокусе. Для этого необходимо, чтобы был установлен определенный контекст рисования (например, цвета и шрифты).
    	</p>
    	<p>
    	    <b>Ч</b>тобы установить состояние, можно использовать шаблонный метод Display. В классе View определены две конкретные операции (SetFocus и ResetFocus), которые соответственно устанавливают и сбрасывают контекст рисования. Операция-зацепка DoDisplay класса View занимается собственно рисованием. Display вызывает SetFocus перед DoDisplay, чтобы подготовить контекст, и ResetFocus после DoDisplay - чтобы его сбросить:
        </p>
        <pre>
        <span class="cl_bl">void</span> View<span class="cl_symb">::</span>Display () {
            SetFocus();
            DoDisplay();
            ResetFocus'() ;
        }
        </pre>
        <p>
           <b>С</b> целью поддержки инварианта клиенты класса.View всегда вызывают Display и подклассы View всегда замещают DoDisplay. В классе View операция DoDisplay не делает ничего:
        </p>
        <p>
            <b>В</b> классе View операция DoDisplay не делает ничего:
        </p>
        <pre>
        <span class="cl_bl">void</span> View<span class="cl_symb">::</span>DooDisplay () { }
        </pre>
        <p>
            <b>Ч</b>тобы она что-то рисовала, подклассы переопределяют ее:
        </p>
        <pre>
        <span class="cl_bl">void</span> MyView<span class="cl_symb">::</span>DooDisplay () {
            <span class="cl_com">// изобразить содержимое вида</span>
        }
        </pre>
        <h2>Известные применения</h2>
        <p>
            <b>Ш</b>аблонные методы настолько фундаментальны, что встречаются почти в каждом абстрактном классе. В работах Ребекки Вирфс-Брок и др. [WBWW90, WBJ90] подробно обсуждаются шаблонные методы.
        </p>
        <h2>Родственные паттерны</h2>
        <p>
            <b>Ф</b>абричные методы часто вызываются из шаблонных. В примере из раздела «Мотивация» шаблонный метод OpenDocument вызывал фабричный метод DoCreateDocument.
        </p>
        <p>
            <b>С</b>тратегия: шаблонные методы применяют наследование для модификации части алгоритма. Стратегии используют делегирование для модификации алгоритма в целом.
        </p>
    </main>
    <footer>
        <div class="footer">
            <div id=el_paso>
                Made by <b>el paso</b>
            </div>
            <div id="copy">
                Rivne 2016
            </div>
        </div> 
    </footer> 
</body>
</html>
