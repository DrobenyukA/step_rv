<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"/>
	<meta name="description" content=""/>
	<meta name="keywords" content=""/>
	<meta name=viewport content="width=device-width, initial-scale=1">	
	<title>Strategy  - pattern</title>
	<link rel="stylesheet" href="../css/reset.css"/>
	<link rel="stylesheet" href="../css/anatoliy_page_style.css"/>
</head>
<body>
	<header>
		<div class="text">
			<h4>Design Patterns</h4>
		</div>
		<h2>паттерн strategy</h2>
		<div class="button">
			<a href="../index.html">
				<h4>home</h4>
			</a>
		</div>
	</header>
	<main>
	    <div class="arrow">
    	<a href="#top" title="go on top"></a>
  	    </div>
	    <h2>Название и классификация паттерна</h2>
		<p>
		    <b>С</b>тратегия - паттерн поведения объектов.
		</p>
		<h2>Назначение</h2>
		<p>
		    <b>О</b>пределяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.
		</p>
		<h2>Известен также под именем</h2>
		<p>
		    <b>P</b>olicy (политика).
		</p>
		<h2>Мотивация</h2>
		<p>
		    <b>С</b>уществует много алгоритмов для разбиения текста на строки. Жестко «зашивать» все подобные алгоритмы в классы, которые в лих нуждаются, нежелательно по нескольким причинам:
		</p>
		<ul>
		    <li>
		    клиент, которому требуется алгоритм разбиения на строки, усложняется при включении в него соответствующего кода. Таким образом, клиенты становятся более громоздкими, а сопровождать их труднее, особенно если нужно поддержать сразу несколько алгоритмов;
		    </li>
		    <li>
		    в зависимости от обстоятельств стоит применять тот или иной алгоритм. Не хотелось бы поддерживать несколько алгоритмов разбиения на строки, если мы не будем ими пользоваться;
		    </li>
		    <li>
		    если разбиение на строки - неотъемлемая часть клиента, то задача добавления новых и модификации существующих алгоритмов усложняется.
		    </li>
		</ul>
		<p>
		    <b>В</b>сех этих проблем можно избежать, если определить классы, инкапсулирующие различные алгоритмы разбиения на строки. Инкапсулированный таким образом алгоритм называется стратегией.
		</p>
		<img src="../img/pages/9/pg_9_1.png" height="160" width="562" alt="scheme">
		<p>
		    <b>П</b>редположим, что класс Composition отвечает за разбиение на строки текста, отображаемого в окне программы просмотра, и его своевременное обновление. Стратегии разбиения на строки определяются не в классе Composition, а в подклассах абстрактного класса Compositor. Это могут быть, например, такие стратегии:
		</p>
		<ul>
		    <li>
		    SimpleCompositor реализует простую стратегию, выделяющую по одной строке за раз;
		    </li>
		    <li>
		    TeXCompositor реализует алгоритм поиска точек разбиения на строки, принятый в редакторе TJX. Эта стратегия пытается выполнить глобальную оптимизацию разбиения на строки, рассматривая сразу целый параграф;
		    </li>
		    <li>
		    ArrayCompositor реализует стратегию расстановки переходов на новую строку таким образом, что в каждой строке оказывается одно и то же число элементов. Это полезно, например, при построчном отображении набора пиктограмм.
		    </li>
		</ul>
		<p>
		    <b>О</b>бъект Composition хранит ссылку на объект Compositor. Всякий раз, когда объекту Composition требуется переформатировать текст, он делегирует данную обязанность своему объекту Compositor. Клиент указывает, какой объект Compositor следует использовать, параметризуя им объект Composition.
		</p>
		<h2>Применимость</h2>
		<p>
		    <b>И</b>спользуйте паттерн стратегия, когда:
		</p>
		<ul>
		    <li>
		    имеется много родственных классов, отличающихся только поведением. Стратегия позволяет сконфигурировать класс, задав одно из возможных поведений;
		    </li>
		    <li>
		    вам нужно иметь несколько разных вариантов алгоритма. Например, можно определить два варианта алгоритма, один из которых требует больше времени, а другой - больше памяти. Стратегии разрешается применять, когда варианты алгоритмов реализованы в виде иерархии классов [НО87];
		    </li>
		    <li>
		    в алгоритме содержатся данные, о которых клиент не должен «знать». Используйте паттерн стратегия, чтобы не раскрывать сложные, специфичные для алгоритма структуры данных;
		    </li>
		    <li>
		    в классе определено много поведений, что представлено разветвленными условными операторами. В этом случае проще перенести код из ветвей в отдельные классы стратегий.
		    </li>
		</ul>
		<h2>Структура</h2>
		<img src="../img/pages/9/pg_9_2.png" height="159" width="538" alt="scheme">  
		<h2>Участники</h2>
		<dl>
		    <dt>
		    Strategy (Compositor) - стратегия:
		    </dt>
		    <dd>
		    объявляет общий для всех поддерживаемых алгоритмов интерфейс. Класс Context пользуется этим интерфейсом для вызова конкретного алгоритма, определенного в классе ConcreteStrategy;
		    </dd>
		</dl>
	    <dl>
		    <dt>
		    ConcreteStrategy (SimpleCompositor, TeXCompositor, ArrayCompositor) - конкретная стратегия:
		    </dt>
	        <dd>
	        реализует алгоритм, использующий интерфейс, объявленный в классе Strategy;
	        </dd>
	    </dl>
	    <dl>
		    <dt>
		    Context (Composition) - контекст:
		    </dt>
	        <dd>
	        конфигурируется объектом класса ConcreteStrategy;
	        </dd>
	        <dd>
	        хранит ссылку на объект класса Strategy;
	        </dd>
	        <dd>
	        может определять интерфейс, который позволяет объекту Strategy получить доступ к данным контекста.
	        </dd>
	    </dl>
		<h2>Отношения</h2>
		<ul>
		    <li>
		    классы Strategy и Context взаимодействуют для реализации выбранного алгоритма. Контекст может передать стратегии все необходимые алгоритму данные в момент его вызова. Вместо этого контекст может позволить обращаться к своим операциям в нужные моменты, передав ссылку на самого себя операциям класса Strategy;
		    </li>
		    <li>
		    контекст переадресует запросы своих клиентов объекту-стратегии. Обычно клиент создает объект ConcreteStrategy и передает его контексту, послечего клиент «общается» исключительно с контекстом. Часто в распоряжении клиента находится несколько классов ConcreteStrategy, которые он может выбирать.
		    </li>
		</ul>
		<h2>Результаты</h2>
		<p>
		    <b>У</b> паттерна стратегия есть следующие достоинства и недостатки:
		</p>
		<ul>
		    <li>
		    семейства родственных алгоритмов. Иерархия классов Strategy определяет семейство алгоритмов или поведений, которые можно повторно использовать в разных контекстах. Наследование позволяет вычленить общую для всех алгоритмов функциональность;
		    </li>
		    <li>
		    альтернатива порождению подклассов. Наследование поддерживает многообразие алгоритмов или поведений. Можно напрямую породить от Context подклассы с различными поведениями. Но при этом поведение жестко «зашивается» в класс Context. Вот почему реализации алгоритма и контекста смешиваются, что затрудняет понимание, сопровождение и расширение контекста. Кроме того, заменить алгоритм динамически уже не удастся. В результате вы получите множество родственных классов, отличающихся только алгоритмом или поведением. Инкапсуляции алгоритма в отдельный класс Strategy позволяют изменять его независимо от контекста;
		    </li>
		    <li>
		    с помощью стратегий можно избавиться от условных операторов. Благодаря паттерну стратегия удается отказаться от условных операторов при выборе нужного поведения. Когда различные поведения помещаются в один класс, трудно выбрать нужное без применения условных операторов. Инкапсуляция же каждого поведения в отдельный класс Strategy решает эту проблему. Так, без использования стратегий код для разбиения текста на строки мог бы выглядеть следующим образом:
		    </li>
		</ul>
		<pre>
		    <span style="color: #333399; font-weight: bold">void</span> Composition<span style="color: #333333">:</span> <span style="color: #333333">:</span>Repair () {
	            <span style="color: #008800; font-weight: bold">switch</span> (_breakingStrategy) {
	            <span style="color: #008800; font-weight: bold">case</span> SimpleStrategy:
	                ComposeWithSimpleCompositor () ;
	                <span style="color: #008800; font-weight: bold">break</span>;
	            <span style="color: #008800; font-weight: bold">case</span> TeXStrategy:
	                ComposeWithTeXCompositor ( ) ;
	                <span style="color: #008800; font-weight: bold">break</span>;
	            <span style="color: #888888">// ...</span>
	            }
	            <span style="color: #888888">// если необходимо, объединить результаты с имеющейся</span>
	            <span style="color: #888888">// композицией</span>
	        }
	    </pre>
	    <p>
	        <b>П</b>аттерн же стратегия позволяет обойтись без оператора переключения за счет делегирования задачи разбиения на строки объекту Strategy:
	    </p>
	    <pre>
	        <span style="color: #333399; font-weight: bold">void</span> Composition<span style="color: #333333">::</span>Repair () {
	            _compositor<span style="color: #333333">-&gt;</span>Compose();
	            <span style="color: #888888">// если необходимо, объединить результаты</span>
	            <span style="color: #888888">// с имеющейся композицией</span>
	        }
	    </pre>
	    <p>
	        <b>Е</b>сли код содержит много условных операторов, то часто это признак того, что нужно применить паттерн стратегия;
	    </p>
	    <ul>
	        <li>
	        выбор реализации. Стратегии могут предлагать различные реализации одного и того же поведения. Клиент вправе выбирать подходящую стратегию в зависимости от своих требований к быстродействию и памяти;
	        </li>
	        <li>
	        клиенты должны &lt;&lt;знатъ&gt;&gt; о различных стратегиях. Потенциальный недостаток этого паттерна в том, что для выбора подходящей стратегии клиент должен понимать, чем отличаются разные стратегии. Поэтому наверняка придется раскрыть клиенту некоторые особенности реализации. Отсюда следует, что паттерн стратегия стоит применять лишь тогда, когда различия в поведении имеют значение для клиента;
	        </li>
	        <li>
	        обмен информацией между стратегией и контекстом. Интерфейс класса Strategy разделяется всеми подклассами ConcreteStrategy — неважно, сложна или тривиальна их реализация. Поэтому вполне вероятно, что некоторые стратегии не будут пользоваться всей передаваемой им информацией, особенно простые. Это означает, что в отдельных случаях контекст создаст и проинициализирует параметры, которые никому не нужны. Если возникнет проблема, то между классами Strategy и Context придется установить более тесную связь;
	        </li>
	        <li>
	        увеличение числа объектов. Применение стратегий увеличивает число объектов в приложении. Иногда эти издержки можно сократить, если реализовать стратегии в виде объектов без состояния, которые могут разделяться несколькими  онтекстами. Остаточное состояние хранится в самом контексте и передается при каждом обращении к объекту-стратегии. Разделяемые стратегии не должны сохранять состояние между вызовами. В описании паттерна приспособленец этот подхбд обсуждается более подробно.
	        </li>
	    </ul>
	    <h2>Реализация</h2>
	    <p>
	        <b>Р</b>ассмотрим следующие вопросы реализации:
	    </p>
	    <ul>
	        <li>
	        определение интерфейсов классов Strategy и Context. Интерфейсы классов Strategy и Context могут обеспечить объекту класса ConcreteStrategy эффективный доступ к любым данным контекста, и наоборот.<br> 
	        Например, Context передает данные в виде параметров операциям класса Strategy. Это разрывает тесную связь между контекстом и стратегией. При этом не исключено, что контекст будет передавать данные, которые стратегии не нужны. <br>
	        Другой метод - передать контекст в качестве аргумента, в таком случае стратегия будет запрашивать у него данные, или, например, сохранить ссылку на свой контекст, так что передавать вообще ничего не придется. И в том, и в другом случаях стратегия может запрашивать только ту информацию, которая реально необходима. Но тогда в контексте должен быть определен более развитый интерфейс к своим данным, что несколько усиливает связанности классов Strategy и Context.<br> 
	        Какой подход лучше, зависит от конкретного алгоритма и требований, которые он предъявляет к данным;
	        </li>
	        <li>
	        стратегии как параметры шаблона. В C++ для конфигурирования класса стратегией можно использовать шаблоны. Этот способ хорош, только если стратегия определяется на этапе компиляции и ее не нужно менять во время выполнения. Тогда конфигурируемый класс (например, Context) определяется в виде шаблона, для которого класс Strategy является параметром:
	        </li>
	    </ul>
	    <pre>
	        <span style="color: #008800; font-weight: bold">template</span>  <span style="color: #333333">&amp;</span>lt;<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">AStrategy</span><span style="color: #333333">&amp;</span>gt;
	        <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Context</span> {
	            <span style="color: #333399; font-weight: bold">void</span> Operation)) { theStrategy .DoAlgorithm( ) ; }
	            <span style="color: #888888">// ...</span>
	        <span style="color: #008800; font-weight: bold">private</span> <span style="color: #333333">:</span>
	            AStrategy theStrategy;
	        }
	    </pre>
	    <p>
	        <b>З</b>атем этот класс конфигурируется классом Strategy в момент инстанцирования:
	    </p>
	    <pre>
	        <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">MyStrategy</span> {
	        <span style="color: #997700; font-weight: bold">public:</span>
	            <span style="color: #333399; font-weight: bold">void</span> DoAlgorithm( ) ;
	        };

	        Context(MyStrategy<span style="color: #333333">&gt;</span> aContext;
	    </pre>
	    <p>
	        <b>П</b>ри использовании шаблонов отпадает необходимость в абстрактном классе для определения интерфейса Strategy. Кроме того, передача стратегии в виде параметра шаблона позволяет статически связать стратегию с контекстом, вследствие чего повышается эффективность программы;
	        и объекты-стратегии можно не задавать. Класс Context разрешается упростить, если для него отсутствие какой бы то ни было стратегии является нормой. Прежде чем обращаться к объекту Strategy, объект Context проверяет наличие стратегии. Если да, то работа продолжается как обычно, в противном случае контекст реализует некое поведение по умолчанию. Достоинство такого подхода в том, что клиентам вообще не нужно иметь дело со стратегиями, если их устраивает поведение по умолчанию.
	    </p>
	    <h2>Пример кода</h2>
	    <p>
	        <b>И</b>з раздела «Мотивация» мы приведем фрагмент высокоуровневого кода, в основе которого лежат классы Composition и Compositor из библиотеки Interviews [LCI+92].
	    </p>
	    <p>
	        <b>В</b> классе Composition есть коллекция экземпляров класса Component, представляющих текстовые и графические элементы документа. Компоновщик, то есть некоторый подкласс класса Compositor, составляет из объектов-компонентов строки, реализуя ту или иную стратегию разбиения на строки. С каждым объектом ассоциирован его естественный размер, а также свойства растягиваемости и сжимаемости. Растягиваемость определяет, насколько можно увеличивать объект по сравнению с его естественным размером, а сжимаемость — насколько можно этот размер уменьшать. Композиция передает эти значения компоновщику, который использует их, чтобы найти оптимальное место для разрыва строки.
	    </p>
	    <pre>
        <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Composition</span> {
        <span style="color: #997700; font-weight: bold">public:</span>
            Composition(Compositor<span style="color: #333333">*</span>);
            <span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">Repair</span>();
        <span style="color: #997700; font-weight: bold">private:</span>
            Compositor<span style="color: #333333">*</span> _compositor;
            Component<span style="color: #333333">*</span> _components; <span style="color: #888888">// список компонентов</span>
            <span style="color: #333399; font-weight: bold">int</span> _componentCount;    <span style="color: #888888">// число компонентов</span>
            <span style="color: #333399; font-weight: bold">int</span> _lineWidth;         <span style="color: #888888">// ширина строки в композиции Composition</span>
            <span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">*</span> _lineBreaks;       <span style="color: #888888">// позиции точек разрыва строки</span>
                                    <span style="color: #888888">// (измеренные в компонентах)</span>
            <span style="color: #333399; font-weight: bold">int</span> _lineCount;         <span style="color: #888888">// число строк</span>
        }
        </pre>
        <p>
            <b>К</b>огда возникает необходимость изменить расположение элементов, композиция запрашивает у компоновщика позиции точек разрыва строк. При этом она передает компоновщику три массива, в которых описаны естественные размеры, растягиваемость и сжимаемость компонентов. Кроме того, передается число компонентов, ширина строки и массив, в который компоновщик должен поместить позиции точек разрыва. Компоновщик возвращает число рассчитанных им точек разрыва.
        </p>
        <p>
            <b>И</b>нтерфейс класса Compositor позволяет композиции передать компоновщику всю необходимую ему информацию. Приведем пример передачи данных стратегии:
        </p>
        <pre>
            <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Compositor</span> {
            <span style="color: #997700; font-weight: bold">public:</span>
                <span style="color: #008800; font-weight: bold">virtual</span> <span style="color: #333399; font-weight: bold">int</span> Compose(
                    Coord natural[], Coord stretch.<span style="color: #333333">!</span>]. Coord ahrink[],
                    <span style="color: #333399; font-weight: bold">int</span> componentCount, <span style="color: #333399; font-weight: bold">int</span> lineWidth, <span style="color: #333399; font-weight: bold">int</span> breaks[]
                ) <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
            <span style="color: #997700; font-weight: bold">protected:</span>
                Compositor();
            }
        </pre>
        <p>
            <b>З</b>аметим, что Compositor - это абстрактный класс. В его конкретных подклассах определены различные стратегии разбиения на строки.
        </p>
        <p>
            <b>К</b>омпозиция обращается к своему компоновщику посредством операции Repair, которая прежде всего инициализирует массивы, содержащие естественные размеры, растягиваемость и сжимаемость каждого компонента (подробности мы опускаем). Затем Repair вызывает компоновщика для получения позиций точек разрыва и, наконец, отображает документ (этот код также опущен):
        </p>
        <pre>
            <span style="color: #333399; font-weight: bold">void</span> Composition<span style="color: #333333">::</span>Repair () {
                Coord<span style="color: #333333">*</span> natural;
                Coord<span style="color: #333333">*</span> stretchability;
                Coord<span style="color: #333333">*</span> shrinkability;
                <span style="color: #333399; font-weight: bold">int</span> componentCount;
                <span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">*</span> breaks;
                <span style="color: #888888">// подготовить массивы с характеристиками компонентов</span>
                <span style="color: #888888">// ...</span>
                <span style="color: #888888">// определить, где должны быть точки разрыва</span>
                <span style="color: #333399; font-weight: bold">int</span> breakCount;
                breakCount <span style="color: #333333">=</span> _compositor<span style="color: #333333">-&gt;</span>Compose(
                    natural, stretchability, shrinkability,
                    componentCount, _lineWidth, breaks
                );
                <span style="color: #888888">// разместить компоненты с учетом точек разрыва</span>
                <span style="color: #888888">// ...</span>
            }
        </pre>
        <p>
            <b>Т</b>еперь рассмотрим подклассы класса Compositor. Класс SimpleCompositor для определения позиций точек разрыва исследует компоненты по одному:
        </p>
        <pre>
            <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">SimpleCompositor</span> <span style="color: #333333">:</span> <span style="color: #008800; font-weight: bold">public</span> Compositor {
            <span style="color: #997700; font-weight: bold">public:</span>
                SimpleCompositor();

                <span style="color: #008800; font-weight: bold">virtual</span> <span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">Compose</span>(
                    Coord natural[], Coord stretch[], Coord shrink[],
                    <span style="color: #333399; font-weight: bold">int</span> componentCount, <span style="color: #333399; font-weight: bold">int</span> lineWidth, <span style="color: #333399; font-weight: bold">int</span> breaks[]
                );
                <span style="color: #888888">// ...</span>
            }
            </pre>
            <p>
            <b>К</b>ласс TeXCompositor использует более глобальную стратегию. Он рассматривает абзац целиком, принимая во внимание размеры и растягиваемость компонентов. Данный класс также пытается равномерно «раскрасить» абзац, минимизируя ширину пропусков между компонентами:
        </p>
        <pre>
            <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">TeXCompositor</span> <span style="color: #333333">:</span> <span style="color: #008800; font-weight: bold">public</span> Compositor {
            <span style="color: #997700; font-weight: bold">public:</span>
                TeXCompositor();

                <span style="color: #008800; font-weight: bold">virtual</span> <span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">Compose</span>( 
                    oord natural[], Coord stretch[]. Coord shrink[], 
                    <span style="color: #333399; font-weight: bold">int</span> componentCount, <span style="color: #333399; font-weight: bold">int</span> lineWidth, <span style="color: #333399; font-weight: bold">int</span> breaks[]
                ) ;
                <span style="color: #888888">// ...</span>
            }
        </pre>
        <p>
            <b>К</b>ласс ArrayCompositor разбивает компоненты на строки, оставляя между ними равные промежутки:
        </p>
        <pre>
            <span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">ArrayCompositor</span> <span style="color: #333333">:</span> <span style="color: #008800; font-weight: bold">public</span> Compositor {
            <span style="color: #997700; font-weight: bold">public:</span>
                ArrayCompositor(<span style="color: #333399; font-weight: bold">int</span> interval);
                <span style="color: #008800; font-weight: bold">virtual</span> <span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">Compose</span>(
                    Coord natural<span style="color: #333333">!</span>], Coord stretch<span style="color: #333333">!</span>], Coord shrink<span style="color: #333333">!</span>],
                    <span style="color: #333399; font-weight: bold">int</span> componentCount, <span style="color: #333399; font-weight: bold">int</span> lineWidth, <span style="color: #333399; font-weight: bold">int</span> breaks[]
                );
                <span style="color: #888888">// ...</span>
            }
        </pre>
        <p>
            <b>H</b>e все из этих классов используют в полном объеме информацию, переданную операции Compose. SimpleComposiLor игнорирует растягиваемость компонентов, принимая во внимание только их естественную ширину. TeXCompositor использует всю переданную информацию, a ArrayCompositor игнорирует ее.
        </p>
        <p>
            <b>П</b>ри создании экземпляра класса Composition вы передаете ему компоновщик, которым собираетесь пользоваться:
        </p>
        <pre>
            <span style="margin: 0; line-height: 125%">Composition</span><span style="color: #333333">*</span> quick <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Composition (<span style="color: #008800; font-weight: bold">new</span> SimpleCompositor) ;
            Composition<span style="color: #333333">*</span> slick <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Composition (<span style="color: #008800; font-weight: bold">new</span> TeXCompositor);
            Composition<span style="color: #333333">*</span> iconic <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Composition (<span style="color: #008800; font-weight: bold">new</span> ArrayCompositor (<span style="color: #0000DD; font-weight: bold">100</span>) );
        </pre>
        <p>
            <b>И</b>нтерфейс класса Compositor тщательно спроектирован для поддержки всех алгоритмов размещения, которые могут быть реализованы в подклассах. Вряд ли вам захочется изменять данный интерфейс при появлении каждого нового подкласса, поскольку это означало бы переписывание уже существующих подклассов. В общем случае именно интерфейсы классов Strategy и Context определяют, насколько хорошо паттерн стратегия соответствует своему назначению.
        </p>
        <h2>Известные применения</h2>
        <p>
            <b>Б</b>иблиотеки ЕТ++ [WGM88] и Interviews используют стратегии для инкапсуляции алгоритмов разбиения на строки - так, как мы только что видели.
        </p>
        <p>
            <b>В</b> системе RTL для оптимизации кода компиляторов [JML92] с помощью стратегий определяются различные схемы распределения регистров (RegisterAllocator) и политики управления потоком команд (RISCscheduler, CISCscheduler). Это позволяет гибко настраивать оптимизатор для разных целевых машинных архитектур.
        </p>
        <p>
            <b>К</b>аркас ЕТ++ SwapsManager предназначен для построения программ, рассчитывающих цены для различных финансовых инструментов [EG92]. Ключевыми абстракциями для него являются Instrument (инструмент) и YieldCurve (кривая дохода). Различные инструменты реализованы как подклассы класса Instrument. YieldCurve рассчитывает коэффициенты дисконтирования, на основе которых вычисляется текущее значение будущего движения ликвидности. Оба класса делегируют часть своего поведения объектам-стратегиям класса Strategy. В каркасе присутствует семейство конкретных стратегий для генерирования движения ликвидности, оценки оборотов и вычисления коэффициентов дисконтирования. Можно создавать новые механизмы расчетов, конфигурируя классы Instrument и YieldCurve другими объектами конкретных стратегий. Этот подход поддерживает как использование существующих реализаций стратегий в различных сочетаниях, так и определение новых.
        </p>
        <p>
            <b>В</b> библиотеке компонентов Грейди Буча [BV90] стратегии используются как аргументы шаблонов. В классах коллекций поддерживаются три разновидности стратегий распределения памяти: управляемая (распределение из пула), контролируемая (распределение и освобождение защищены замками) и неуправляемая (стандартное распределение памяти). Стратегия передается классу коллекции в виде аргумента шаблона в момент его инстанцирования. Например, коллекция UnboundedCollection, в которой используется неуправляемая стратегия, инстанцируется как UnboundedCollection&lt;MyItemType* , Unmanaged&gt;.
        </p>
        <p>
            <b>R</b>App - это система для проектирования топологии интегральных схем [GA89, AG90]. Задача RApp - проложить провода между различными подсистемами на схеме. Алгоритмы трассировки в RApp определены как подклассы абстрактного класса Router, который является стратегией.
        </p>
        <p>
            <b>В</b> библиотеке ObjectWindows фирмы Borland [Вог94] стратегии используются в диалоговых окнах для проверки правильности введенных пользователем данных. Например, можно контролировать, что число принадлежит заданному диапазону, а в данном поле должны быть только цифры. Не исключено, что при проверке корректности введенной строки потребуется поиск данных в справочной таблице.
        </p>
        <p>
            <b>Д</b>ля инкапсуляции стратегий проверки в ObjectWindows используются объекты класса Validator — частный случай паттерна стратегия. Поля для ввода данных делегируют стратегию контроля необязательному объекту Validator.  Клиент при необходимости присоединяет таких проверяющих к полю (пример необязательной стратегии). В момент закрытия диалогового окна поля «просят» своих контролеров проверить правильность данных. В библиотеке имеются классы контролеров для наиболее распространенных случаев, например RangeValidator для проверки принадлежности числа диапазону. Но клиент может легко определить и собственные стратегии проверки, порождая подклассы от класса Validator.
        </p>
        <h2>Родственные паттерны</h2>
        <p>
            <b>П</b>риспособленец: объекты-стратегии в большинстве случаев подходят как приспособленцы.
        </p>
    </main>
    <footer>
		<div class="footer">
			<div id=el_paso>
				Made by <b>el paso</b>
			</div>
			<div id="copy">
				Rivne 2016
			</div>
		</div> 
	</footer> 
</body>
</html>
